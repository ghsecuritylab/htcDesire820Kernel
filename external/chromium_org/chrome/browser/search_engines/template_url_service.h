// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SEARCH_ENGINES_TEMPLATE_URL_SERVICE_H_
#define CHROME_BROWSER_SEARCH_ENGINES_TEMPLATE_URL_SERVICE_H_

#include <list>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "base/callback_list.h"
#include "base/gtest_prod_util.h"
#include "base/memory/scoped_ptr.h"
#include "base/observer_list.h"
#include "base/prefs/pref_change_registrar.h"
#include "chrome/browser/search_engines/template_url_id.h"
#include "chrome/browser/webdata/web_data_service.h"
#include "components/browser_context_keyed_service/browser_context_keyed_service.h"
#include "content/public/browser/notification_observer.h"
#include "content/public/browser/notification_registrar.h"
#include "sync/api/sync_change.h"
#include "sync/api/syncable_service.h"

class GURL;
class PrefService;
class Profile;
class SearchHostToURLsMap;
class SearchTermsData;
class TemplateURLServiceObserver;

namespace syncer {
class SyncData;
class SyncErrorFactory;
}

namespace history {
struct URLVisitedDetails;
}


class TemplateURLService : public WebDataServiceConsumer,
                           public BrowserContextKeyedService,
                           public content::NotificationObserver,
                           public syncer::SyncableService {
 public:
  typedef std::map<std::string, std::string> QueryTerms;
  typedef std::vector<TemplateURL*> TemplateURLVector;
  
  typedef base::Time(TimeProvider)();
  typedef std::map<std::string, syncer::SyncData> SyncDataMap;
  typedef base::CallbackList<void(void)>::Subscription Subscription;

  
  
  struct Initializer {
    const char* const keyword;
    const char* const url;
    const char* const content;
  };

  
  struct ExtensionKeyword {
    ExtensionKeyword(const std::string& id,
                     const std::string& name,
                     const std::string& keyword);
    ~ExtensionKeyword();

    std::string extension_id;
    std::string extension_name;
    std::string extension_keyword;
  };

  explicit TemplateURLService(Profile* profile);
  
  TemplateURLService(const Initializer* initializers, const int count);
  virtual ~TemplateURLService();

  
  
  
  static base::string16 GenerateKeyword(const GURL& url);

  
  
  static base::string16 CleanUserInputKeyword(const base::string16& keyword);

  
  
  
  
  static GURL GenerateSearchURL(TemplateURL* t_url);

  
  
  
  
  static GURL GenerateSearchURLUsingTermsData(
      const TemplateURL* t_url,
      const SearchTermsData& search_terms_data);

  
  
  
  
  
  
  
  bool CanReplaceKeyword(const base::string16& keyword,
                         const GURL& url,
                         TemplateURL** template_url_to_replace);

  
  
  
  void FindMatchingKeywords(const base::string16& prefix,
                            bool support_replacement_only,
                            TemplateURLVector* matches) const;

  
  
  
  
  TemplateURL* GetTemplateURLForKeyword(const base::string16& keyword);

  
  
  
  TemplateURL* GetTemplateURLForGUID(const std::string& sync_guid);

  
  
  TemplateURL* GetTemplateURLForHost(const std::string& host);

  
  
  void Add(TemplateURL* template_url);

  
  
  void AddAndSetProfile(TemplateURL* template_url, Profile* profile);
  void AddWithOverrides(TemplateURL* template_url,
                        const base::string16& short_name,
                        const base::string16& keyword,
                        const std::string& url);

  
  void AddExtensionControlledTURL(TemplateURL* template_url,
                                  scoped_ptr<AssociatedExtensionInfo> info);

  
  
  void Remove(TemplateURL* template_url);

  
  
  
  void RemoveExtensionControlledTURL(const std::string& extension_id);

  
  
  void RemoveAutoGeneratedSince(base::Time created_after);

  
  
  void RemoveAutoGeneratedBetween(base::Time created_after,
                                  base::Time created_before);

  
  
  
  void RemoveAutoGeneratedForOriginBetween(const GURL& origin,
                                           base::Time created_after,
                                           base::Time created_before);

  
  
  
  void RegisterOmniboxKeyword(const std::string& extension_id,
                              const std::string& extension_name,
                              const std::string& keyword);

  
  
  void UnregisterOmniboxKeyword(const std::string& extension_id);

  
  
  TemplateURLVector GetTemplateURLs();

  
  
  void IncrementUsageCount(TemplateURL* url);

  
  
  void ResetTemplateURL(TemplateURL* url,
                        const base::string16& title,
                        const base::string16& keyword,
                        const std::string& search_url);

  
  
  
  bool CanMakeDefault(const TemplateURL* url);

  
  
  
  void SetDefaultSearchProvider(TemplateURL* url);

  
  
  
  
  TemplateURL* GetDefaultSearchProvider();

  
  
  bool IsSearchResultsPageFromDefaultSearchProvider(const GURL& url);

  
  bool is_default_search_managed() const { return is_default_search_managed_; }

  
  bool IsExtensionControlledDefaultSearch();

  
  
  
  
  TemplateURL* FindNewDefaultSearchProvider();

  
  
  
  
  
  
  
  
  
  void RepairPrepopulatedSearchEngines();

  
  
  void AddObserver(TemplateURLServiceObserver* observer);
  void RemoveObserver(TemplateURLServiceObserver* observer);

  
  
  
  
  void Load();

  
  
  
  scoped_ptr<Subscription> RegisterOnLoadedCallback(
      const base::Closure& callback);

#if defined(UNIT_TEST)
  void set_loaded(bool value) { loaded_ = value; }
#endif

  
  bool loaded() { return loaded_; }

  
  
  
  virtual void OnWebDataServiceRequestDone(
      WebDataService::Handle h,
      const WDTypedResult* result) OVERRIDE;

  
  
  
  base::string16 GetKeywordShortName(const base::string16& keyword,
                                     bool* is_omnibox_api_extension_keyword);

  
  virtual void Observe(int type,
                       const content::NotificationSource& source,
                       const content::NotificationDetails& details) OVERRIDE;

  
  virtual void Shutdown() OVERRIDE;

  

  
  
  virtual syncer::SyncDataList GetAllSyncData(
      syncer::ModelType type) const OVERRIDE;
  
  
  
  virtual syncer::SyncError ProcessSyncChanges(
      const tracked_objects::Location& from_here,
      const syncer::SyncChangeList& change_list) OVERRIDE;
  
  
  
  virtual syncer::SyncMergeResult MergeDataAndStartSyncing(
      syncer::ModelType type,
      const syncer::SyncDataList& initial_sync_data,
      scoped_ptr<syncer::SyncChangeProcessor> sync_processor,
      scoped_ptr<syncer::SyncErrorFactory> sync_error_factory) OVERRIDE;
  virtual void StopSyncing(syncer::ModelType type) OVERRIDE;

  
  
  
  
  
  void ProcessTemplateURLChange(const tracked_objects::Location& from_here,
                                const TemplateURL* turl,
                                syncer::SyncChange::SyncChangeType type);

  Profile* profile() const { return profile_; }

  
  
  static syncer::SyncData CreateSyncDataFromTemplateURL(
      const TemplateURL& turl);

  
  
  
  
  
  
  
  
  static TemplateURL* CreateTemplateURLFromTemplateURLAndSyncData(
      Profile* profile,
      TemplateURL* existing_turl,
      const syncer::SyncData& sync_data,
      syncer::SyncChangeList* change_list);

  
  static SyncDataMap CreateGUIDToSyncDataMap(
      const syncer::SyncDataList& sync_data);

#if defined(UNIT_TEST)
  
  
  void set_time_provider(TimeProvider* time_provider) {
    time_provider_ = time_provider;
  }
#endif

 protected:
  
  
  
  
  virtual void SetKeywordSearchTermsForURL(const TemplateURL* t_url,
                                           const GURL& url,
                                           const base::string16& term);

 private:
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, TestManagedDefaultSearch);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest,
                           UpdateKeywordSearchTermsForURL);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest,
                           DontUpdateKeywordSearchForNonReplaceable);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, ChangeGoogleBaseValue);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, MergeDeletesUnusedProviders);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           CreateSyncDataFromTemplateURL);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           CreateTemplateURLFromSyncData);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, UniquifyKeyword);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           ResolveSyncKeywordConflict);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, PreSyncDeletes);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           IsLocalTemplateURLBetter);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, MergeInSyncTemplateURL);

  friend class TemplateURLServiceTestUtilBase;

  typedef std::map<base::string16, TemplateURL*> KeywordToTemplateMap;
  typedef std::map<std::string, TemplateURL*> GUIDToTemplateMap;

  
  
  
  
  enum DefaultSearchChangeOrigin {
    
    DSP_CHANGE_SYNC_PREF,
    DSP_CHANGE_SYNC_ADD,
    DSP_CHANGE_SYNC_DELETE,
    DSP_CHANGE_SYNC_NOT_MANAGED,
    
    
    
    DSP_CHANGE_SYNC_UNINTENTIONAL,
    
    
    DSP_CHANGE_OTHER,
    
    DSP_CHANGE_PROFILE_RESET,
    
    DSP_CHANGE_OVERRIDE_SETTINGS_EXTENSION,
    
    DSP_CHANGE_MAX,
  };

  
  
  class LessWithPrefix;

  void Init(const Initializer* initializers, int num_initializers);

  void RemoveFromMaps(TemplateURL* template_url);

  void AddToMaps(TemplateURL* template_url);

  
  
  
  
  
  
  void SetTemplateURLs(TemplateURLVector* urls);

  
  void ChangeToLoadedState();

  
  
  void SaveDefaultSearchProviderToPrefs(const TemplateURL* url);

  
  
  
  
  
  
  bool LoadDefaultSearchProviderFromPrefs(
      scoped_ptr<TemplateURL>* default_provider,
      bool* is_managed);

  
  void ClearDefaultProviderFromPrefs();

  
  
  
  bool CanReplaceKeywordForHost(const std::string& host,
                                TemplateURL** to_replace);

  
  
  
  
  bool CanReplace(const TemplateURL* t_url);

  
  TemplateURL* FindNonExtensionTemplateURLForKeyword(
      const base::string16& keyword);

  
  
  
  
  
  
  
  
  bool UpdateNoNotify(TemplateURL* existing_turl,
                      const TemplateURL& new_values,
                      const SearchTermsData& old_search_terms_data);

  
  
  
  
  static void UpdateTemplateURLIfPrepopulated(TemplateURL* existing_turl,
                                              Profile* profile);

  
  PrefService* GetPrefs();

  
  
  
  void UpdateKeywordSearchTermsForURL(
      const history::URLVisitedDetails& details);

  
  void AddTabToSearchVisit(const TemplateURL& t_url);

  
  
  
  void GoogleBaseURLChanged(const GURL& old_base_url);

  
  
  void UpdateDefaultSearch();

  
  
  
  
  
  
  
  
  
  bool SetDefaultSearchProviderNoNotify(TemplateURL* url);

  
  
  
  
  
  
  
  
  
  
  bool AddNoNotify(TemplateURL* template_url, bool newly_adding);

  
  
  
  void RemoveNoNotify(TemplateURL* template_url);

  
  
  void NotifyObservers();

  
  
  
  
  void RemoveProvidersCreatedByPolicy(
      TemplateURLVector* template_urls,
      TemplateURL** default_search_provider,
      TemplateURL* default_from_prefs);

  
  
  void ResetTemplateURLGUID(TemplateURL* url, const std::string& guid);

  
  
  
  
  
  
  base::string16 UniquifyKeyword(const TemplateURL& turl, bool force);

  
  
  
  
  
  
  
  
  
  bool IsLocalTemplateURLBetter(const TemplateURL* local_turl,
                                const TemplateURL* sync_turl);

  
  
  
  
  
  
  
  
  void ResolveSyncKeywordConflict(TemplateURL* unapplied_sync_turl,
                                  TemplateURL* applied_sync_turl,
                                  syncer::SyncChangeList* change_list);

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  void MergeInSyncTemplateURL(TemplateURL* sync_turl,
                              const SyncDataMap& sync_data,
                              syncer::SyncChangeList* change_list,
                              SyncDataMap* local_data,
                              syncer::SyncMergeResult* merge_result);

  
  
  void SetDefaultSearchProviderIfNewlySynced(const std::string& guid);

  
  
  TemplateURL* GetPendingSyncedDefaultSearchProvider();

  
  
  
  void PatchMissingSyncGUIDs(TemplateURLVector* template_urls);

  void OnSyncedDefaultSearchProviderGUIDChanged();

  
  
  
  
  
  
  
  
  void AddTemplateURLsAndSetupDefaultEngine(
      TemplateURLVector* template_urls,
      TemplateURL* default_search_provider);

  
  
  void EnsureDefaultSearchProviderExists();

  
  TemplateURL* CreateTemplateURLForExtension(
      const ExtensionKeyword& extension_keyword) const;

  
  TemplateURL* FindTemplateURLForExtension(const std::string& extension_id,
                                           TemplateURL::Type type) const;

  
  
  TemplateURL* FindExtensionDefaultSearchEngine() const;

  
  
  
  
  
  void SetDefaultSearchProviderAfterRemovingDefaultExtension();

  content::NotificationRegistrar notification_registrar_;
  PrefChangeRegistrar pref_change_registrar_;

  
  KeywordToTemplateMap keyword_to_template_map_;

  
  GUIDToTemplateMap guid_to_template_map_;

  TemplateURLVector template_urls_;

  ObserverList<TemplateURLServiceObserver> model_observers_;

  
  
  
  scoped_ptr<SearchHostToURLsMap> provider_map_;

  
  
  
  Profile* profile_;

  
  bool loaded_;

  
  bool load_failed_;

  
  WebDataService::Handle load_handle_;

  
  scoped_refptr<WebDataService> service_;

  
  
  std::vector<history::URLVisitedDetails> visits_to_add_;

  
  
  TemplateURL* default_search_provider_;

  
  
  scoped_ptr<TemplateURL> initial_default_search_provider_;

  
  bool is_default_search_managed_;

  
  
  TemplateURLID next_id_;

  
  TimeProvider* time_provider_;

  
  
  
  
  bool models_associated_;

  
  
  bool processing_syncer_changes_;

  
  scoped_ptr<syncer::SyncChangeProcessor> sync_processor_;

  
  scoped_ptr<syncer::SyncErrorFactory> sync_error_factory_;

  
  
  
  
  
  bool pending_synced_default_search_;

  
  
  
  
  std::set<std::string> pre_sync_deletes_;

  
  
  
  DefaultSearchChangeOrigin dsp_change_origin_;

  
  base::CallbackList<void(void)> on_loaded_callbacks_;

  DISALLOW_COPY_AND_ASSIGN(TemplateURLService);
};

#endif  
