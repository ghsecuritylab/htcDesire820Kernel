// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_HISTORY_H_
#define CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_HISTORY_H_


#include <string>
#include <vector>

#include "base/callback.h"
#include "base/containers/hash_tables.h"
#include "base/memory/linked_ptr.h"
#include "base/memory/ref_counted.h"
#include "base/sequenced_task_runner_helpers.h"
#include "chrome/browser/history/history_service.h"
#include "content/public/browser/browser_thread.h"
#include "content/public/browser/notification_observer.h"
#include "content/public/browser/notification_registrar.h"
#include "net/base/completion_callback.h"

namespace safe_browsing {
typedef std::vector<GURL> RedirectChain;
}

class MalwareDetailsRedirectsCollector
    : public base::RefCountedThreadSafe<
          MalwareDetailsRedirectsCollector,
          content::BrowserThread::DeleteOnUIThread>,
      public content::NotificationObserver {
 public:
  explicit MalwareDetailsRedirectsCollector(Profile* profile);

  
  
  
  void StartHistoryCollection(const std::vector<GURL>& urls,
                              const base::Closure& callback);

  
  bool HasStarted() const;

  
  const std::vector<safe_browsing::RedirectChain>& GetCollectedUrls() const;

  
  virtual void Observe(int type,
                       const content::NotificationSource& source,
                       const content::NotificationDetails& details) OVERRIDE;

 private:
  friend struct content::BrowserThread::DeleteOnThread<
      content::BrowserThread::UI>;
  friend class base::DeleteHelper<MalwareDetailsRedirectsCollector>;

  virtual ~MalwareDetailsRedirectsCollector();

  void StartGetRedirects(const std::vector<GURL>& urls);
  void GetRedirects(const GURL& url);
  void OnGotQueryRedirectsTo(HistoryService::Handle handle,
                             GURL url,
                             bool success,
                             history::RedirectList* redirect_list);

  
  
  void AllDone();

  Profile* profile_;
  CancelableRequestConsumer request_consumer_;

  
  
  base::Closure callback_;

  
  bool has_started_;

  
  std::vector<GURL> urls_;
  
  std::vector<GURL>::iterator urls_it_;
  
  std::vector<safe_browsing::RedirectChain> redirects_urls_;

  content::NotificationRegistrar registrar_;

  DISALLOW_COPY_AND_ASSIGN(MalwareDetailsRedirectsCollector);
};

#endif  
