// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_H_
#define CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_H_
#pragma once



#include <string>
#include <vector>

#include "base/hash_tables.h"
#include "base/memory/linked_ptr.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "chrome/browser/safe_browsing/report.pb.h"
#include "chrome/browser/safe_browsing/safe_browsing_service.h"
#include "content/browser/tab_contents/tab_contents_observer.h"
#include "net/base/completion_callback.h"

class TabContents;
struct SafeBrowsingHostMsg_MalwareDOMDetails_Node;

class MalwareDetailsCacheCollector;
class MalwareDetailsFactory;

namespace safe_browsing {
typedef base::hash_map<
  std::string,
  linked_ptr<safe_browsing::ClientMalwareReportRequest::Resource> > ResourceMap;
}

class MalwareDetails : public base::RefCountedThreadSafe<MalwareDetails>,
                       public TabContentsObserver {
 public:
  
  static MalwareDetails* NewMalwareDetails(
      SafeBrowsingService* sb_service,
      TabContents* tab_contents,
      const SafeBrowsingService::UnsafeResource& resource);

  
  
  static void RegisterFactory(MalwareDetailsFactory* factory) {
    factory_ = factory;
  }

  
  
  
  
  void FinishCollection();

  void OnCacheCollectionReady();

  
  virtual bool OnMessageReceived(const IPC::Message& message);

 protected:
  friend class MalwareDetailsFactoryImpl;

  MalwareDetails(SafeBrowsingService* sb_service,
                 TabContents* tab_contents,
                 const SafeBrowsingService::UnsafeResource& resource);

  virtual ~MalwareDetails();

  
  virtual void AddDOMDetails(
      const std::vector<SafeBrowsingHostMsg_MalwareDOMDetails_Node>& params);

  
  scoped_ptr<safe_browsing::ClientMalwareReportRequest> report_;

  
  scoped_refptr<net::URLRequestContextGetter> request_context_getter_;

 private:
  friend class base::RefCountedThreadSafe<MalwareDetails>;

  
  void StartCollection();

  
  bool IsPublicUrl(const GURL& url) const;

  
  
  
  safe_browsing::ClientMalwareReportRequest::Resource* FindOrCreateResource(
      const GURL& url);

  
  
  void AddUrl(const GURL& url,
              const GURL& parent,
              const std::string& tagname,
              const std::vector<GURL>* children);

  
  void OnReceivedMalwareDOMDetails(
      const std::vector<SafeBrowsingHostMsg_MalwareDOMDetails_Node>& params);

  scoped_refptr<SafeBrowsingService> sb_service_;

  const SafeBrowsingService::UnsafeResource resource_;

  
  
  safe_browsing::ResourceMap resources_;

  
  bool cache_result_;

  
  
  
  static MalwareDetailsFactory* factory_;

  
  scoped_refptr<MalwareDetailsCacheCollector> cache_collector_;

  FRIEND_TEST_ALL_PREFIXES(MalwareDetailsTest, MalwareDOMDetails);
  FRIEND_TEST_ALL_PREFIXES(MalwareDetailsTest, HTTPCache);
  FRIEND_TEST_ALL_PREFIXES(MalwareDetailsTest, HTTPCacheNoEntries);

  DISALLOW_COPY_AND_ASSIGN(MalwareDetails);
};

class MalwareDetailsFactory {
 public:
  virtual ~MalwareDetailsFactory() { }

  virtual MalwareDetails* CreateMalwareDetails(
      SafeBrowsingService* sb_service,
      TabContents* tab_contents,
      const SafeBrowsingService::UnsafeResource& unsafe_resource) = 0;
};

#endif  
