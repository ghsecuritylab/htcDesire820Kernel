// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_CACHE_H_
#define CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_CACHE_H_
#pragma once


#include <string>
#include <vector>

#include "base/hash_tables.h"
#include "base/memory/linked_ptr.h"
#include "base/memory/ref_counted.h"
#include "chrome/browser/safe_browsing/report.pb.h"
#include "chrome/common/net/url_fetcher.h"
#include "net/base/completion_callback.h"

namespace net {
class URLRequestContext;
}

class MalwareDetailsFactory;

namespace safe_browsing {

typedef base::hash_map<
  std::string,
  linked_ptr<safe_browsing::ClientMalwareReportRequest::Resource> > ResourceMap;
}

class MalwareDetailsCacheCollector
    : public base::RefCountedThreadSafe<MalwareDetailsCacheCollector>,
      public URLFetcher::Delegate {

 public:
  MalwareDetailsCacheCollector();
  virtual ~MalwareDetailsCacheCollector();

  
  
  
  void StartCacheCollection(
      net::URLRequestContextGetter* request_context_getter,
      safe_browsing::ResourceMap* resources,
      bool* result,
      Task* callback);

  
  bool HasStarted();

 protected:
  
  
  virtual void OnURLFetchComplete(const URLFetcher* source,
                                  const GURL& url,
                                  const net::URLRequestStatus& status,
                                  int response_code,
                                  const ResponseCookies& cookies,
                                  const std::string& data);

 private:
  
  
  safe_browsing::ResourceMap::iterator resources_it_;

  
  safe_browsing::ResourceMap* resources_;

  
  bool* result_;

  
  
  Task* callback_;

  
  bool has_started_;

  
  scoped_refptr<net::URLRequestContextGetter> request_context_getter_;

  
  scoped_ptr<URLFetcher> current_fetch_;

  
  safe_browsing::ClientMalwareReportRequest::Resource* GetResource(
      const GURL& url);

  
  void OpenEntry();

  
  void ReadResponse(
      safe_browsing::ClientMalwareReportRequest::Resource* pb_resource,
      const URLFetcher* source);

  
  void ReadData(
      safe_browsing::ClientMalwareReportRequest::Resource* pb_resource,
      const std::string& data);

  
  void AllDone(bool success);

  
  void AdvanceEntry();
};

#endif  
